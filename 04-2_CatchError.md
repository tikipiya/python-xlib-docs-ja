# 4.2 CatchError

`error.CatchError` は、エラーハンドラーとして使用できるオブジェクトです。指定されたタイプのいずれかにマッチするエラーを収集し、後で取得できます。複数のエラーが発生した場合、最後のエラーのみが記憶されます。

## CatchErrorクラス

**CatchError** _( *error_classes )_

新しいエラーハンドラーオブジェクトを作成します。関心のあるすべてのエラークラスを引数として提供して初期化します。エラークラスが全く提供されない場合、すべてのエラーが考慮されることを意味します。

## 使用方法

`error.CatchError` オブジェクトを、Xオブジェクトメソッドの `onerror` パラメータとして渡します。これらのメソッドが指定されたものにマッチするエラーを生成した場合、以下の関数で取得できます：

### `get_error()`
キャッチされた最後のエラーオブジェクトを返します。マッチするエラーが発生していない場合は `None` を返します。

### `get_request()`
キャッチされた最後のエラーのリクエストオブジェクトを返します。マッチするエラーが発生していない場合は `None` を返します。

### `reset()`
キャッチされたエラーを忘れます。

## 再利用

`error.CatchError` オブジェクトは再利用できます。

## 同期の重要性

Xプロトコルは主に非同期であるため、監視しているエラーが `get_error()` を呼び出すときにまだ受信されていない可能性があります。リクエストがサーバーで処理され、生成されたエラーがXlibで受信されたことを確認するために、サーバーと同期する必要があります。

## 実用例

```python
# foo ウィンドウをリサイズする
# 最後に確認してから破棄されている場合、
# 変数 foo を None にリセットする

# BadWindow エラー用のエラーハンドラーを作成
ec = error.CatchError(error.BadWindow)

# 操作を実行
foo.configure(width = 100, height = 200, onerror = ec)

# サーバーとの通信を同期
display.sync()

# エラーがあったかチェック
if ec.get_error():
    foo = None
```

## 重要なポイント

- **非同期処理**: Xプロトコルの非同期性により、`display.sync()` が重要
- **エラーの上書き**: 複数のエラーが発生した場合、最後のもののみが保持される
- **再利用可能**: 同じ `CatchError` オブジェクトを複数回使用可能
- **柔軟な指定**: 特定のエラータイプまたはすべてのエラーを捕捉可能