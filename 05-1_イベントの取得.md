# 5.1 イベントの取得

イベントはクライアントがイベントを受信する準備ができていない時でも、任意のタイミングで送信される可能性があります。そのため、ネットワークから読み込まれた時点からクライアントが処理する準備ができるまで、一時的に保存される必要があります。読み込み済みだが未処理のイベントは、Displayオブジェクトのイベントキューに保存されます。

## イベントキューへのアクセス

このキューにアクセスするための2つの関数があります：

### `next_event()`
イベントキューの次のイベントを返します。イベントキューが空の場合、ネットワークからイベントが読み込まれるまでブロックし、そのイベントを返します。

### `pending_events()`
ブロックせずに返すことができるイベントの数を返します。

## 基本的なイベントループ

単純なイベントループは、無限にループし、イベントを待機してから処理することができます：

```python
while 1:
   event = disp.next_event()
   handle_event(event)
```

## より高度なイベントループ

しかし、ほとんどのアプリケーションは、同時にネットワーク接続を処理したり、定期的なタイムアウトをスケジュールしたりするなど、より多くの制御を必要とします。このために `select` モジュールがよく使用されます。

### selectとの組み合わせ

`Display` オブジェクトは必要な `fileno()` メソッドを持つため、`select` と組み合わせて使用できます。`select` が `Display` オブジェクトが読み込み可能であることを示す場合、それはサーバーがクライアントにデータを送信したことを意味します。

これだけでは完全なイベントが到着したことを保証しないため、最初に `pending_events()` を使用して `next_event()` がブロックせずに返されることを確認する必要があります。

### 実用的な例

イベントまたは1秒のタイムアウトを待機する簡単なイベントループの例：

```python
while 1:
    # ディスプレイが何かを送信するか、1秒のタイムアウトを待機
    readable, w, e = select.select([disp], [], [], 1)

    # 読み込み可能なファイルがない場合、タイムアウト
    if not readable:
        handle_timeout()

    # ディスプレイが読み込み可能な場合、受信したすべてのイベントを処理
    elif disp in readable:
        i = disp.pending_events()
        while i > 0:
            event = disp.next_event()
            handle_event(event)
            i = i - 1

    # より多くのことが起こるのを待つためにループを繰り返す
```

この方法により、アプリケーションはイベント処理とタイムアウト処理の両方を効率的に管理できます。